<<main.cpp 파일>>

int main()
{
    initscr();
    resize_term(40, 100);
    keypad(stdscr, TRUE);
    curs_set(0);
    noecho();
    start_color();
    init_pair(1, COLOR_YELLOW, COLOR_BLACK);
    bkgd(COLOR_PAIR(1));
    attron(COLOR_PAIR(1));

    Game game;
    game.gameStart();

    //게임이 완전히 끝날때까지 반복
    while (!game.checkAllSuccess())
    {
        border('*', '*', '*', '*', '*', '*', '*', '*');

        //맵 그리기
        for (int j = 0; j < game.getMaps()[game.getCurrentStage()].size(); j++)
        {
            for (int k = 0; k < game.getMaps()[game.getCurrentStage()][j].size(); k++)
            {
                if (game.getMaps()[game.getCurrentStage()][j][k] == 5)
                    mvprintw(20 + j, 20 + k, "#");
                else if (game.getMaps()[game.getCurrentStage()][j][k] == 4)
                    mvprintw(20 + j, 20 + k, " ");
                else
                    mvprintw(20 + j, 20 + k, "%d", game.getMaps()[game.getCurrentStage()][j][k]);
            }
        }
        refresh();

        //입력받아 움직이기
        int input = getch();

        game.move(input);

        //화면 지우기
        clear();
    }
    attroff(COLOR_PAIR(1));
    endwin();
}

<<Game.h 파일>>

class Game
{
private:
    int numOfStages, currentStage;
    vector<bool> finished;
    vector<vector<vector<int>>> maps;
    vector<pair<int, int>> playerPositions;
    vector<vector<pair<int, int>>> goalPositions;
    
public:
    int getCurrentStage() { return currentStage; }
    vector<vector<vector<int>>> getMaps() { return maps; }

    void gameStart();
    void setMaps();
    void setPlayer();
    void move(const int direction);
    void walk(const int y, const int x, const int nextY, const int nextX);
    void push(const int y, const int x, const int nextY, const int nextX, const int afterY, const int afterX);
    bool checkGoal(const int y, const int x) const;
    bool checkAllSuccess() const;
};

<<Game.cpp 파일>>

//모든 스테이지가 완료되었는지 체크하는 함수
bool Game::checkAllSuccess() const
{
    for (int i = 0; i < finished.size(); i++)
        if (finished[i] == false)
            return false;
    return true;
}

void Game::move(const int direction)
{
    int y = playerPositions[currentStage].first;
    int x = playerPositions[currentStage].second;
    int nextY, nextX, afterY, afterX;
    if (direction == KEY_UP)
    {
        nextY = y - 1;
        nextX = x;
        afterY = y - 2;
        afterX = x;
    }
    else if (direction == KEY_DOWN)
    {
        nextY = y + 1;
        nextX = x;
        afterY = y + 2;
        afterX = x;
    }
    else if (direction == KEY_LEFT)
    {
        nextY = y;
        nextX = x - 1;
        afterY = y;
        afterX = x - 2;
    }
    else if (direction == KEY_RIGHT)
    {
        nextY = y;
        nextX = x + 1;
        afterY = y;
        afterX = x + 2;
    }

    //다음칸이 벽이 아닐 때
    if (maps[currentStage][nextY][nextX] != 1)
    {
        //다음칸이 비어있을 때 그냥 앞으로 전진
        if (maps[currentStage][nextY][nextX] == 0 || maps[currentStage][nextY][nextX] == 3)
            walk(y, x, nextY, nextX);
        //다음칸이 상자일 때
        else
            //다음다음칸이 빈칸일 경우 PUSH
            if (maps[currentStage][afterY][afterX] == 0 || maps[currentStage][afterY][afterX] == 3)
                push(y, x, nextY, nextX, afterY, afterX);
    }
}

//빈칸으로 한 칸 앞으로 가는 함수
void Game::walk(const int y, const int x, const int nextY, const int nextX)
{
    maps[currentStage][nextY][nextX] = 5;
    maps[currentStage][y][x] = 0;
    playerPositions[currentStage].first = nextY;
    playerPositions[currentStage].second = nextX;

    //원래 있던 자리가 목적지인지 체크하여 변경
    if (checkGoal(y, x))
        maps[currentStage][y][x] = 3;
}

//앞에 상자가 있을 경우 밀면서 한 칸 앞으로 가는 함수
void Game::push(const int y, const int x, const int nextY, const int nextX, const int afterY, const int afterX)
{
    maps[currentStage][afterY][afterX] = 2;
    maps[currentStage][nextY][nextX] = 5;
    maps[currentStage][y][x] = 0;
    playerPositions[currentStage].first = nextY;
    playerPositions[currentStage].second = nextX;

    //원래 있던 자리가 목적지인지 체크하여 변경
    if (checkGoal(y, x))
        maps[currentStage][y][x] = 3;
}


//해당 좌표 위치가 목적지인지 체크하는 함수
bool Game::checkGoal(const int y, const int x) const
{
    for (int i = 0; i < goalPositions[currentStage].size(); i++)
        if (goalPositions[currentStage][i].first == y && goalPositions[currentStage][i].second == x)
            return true;
    return false;
}
